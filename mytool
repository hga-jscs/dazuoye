#!/usr/bin/env python3
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Sequence, Set, Tuple


@dataclass
class Node:
    node_id: str
    data: Dict[str, Any]


@dataclass
class Graph:
    nodes: List[Node]
    id_to_index: Dict[str, int]
    directed_edges: List[List[int]]
    undirected_edges: List[List[int]]


@dataclass
class PlusConfig:
    use_all_wires: bool = False
    allow_disconnected: bool = False
    verbose_debug: bool = True


def load_plus_config(path: Path) -> PlusConfig:
    config = PlusConfig()
    if not path.exists():
        return config
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
        if isinstance(data, dict):
            config.use_all_wires = bool(data.get("use_all_wires", config.use_all_wires))
            config.allow_disconnected = bool(data.get("allow_disconnected", config.allow_disconnected))
            config.verbose_debug = bool(data.get("verbose_debug", config.verbose_debug))
    except Exception as exc:  # noqa: BLE001 - keep debug output clear for students
        print(f"[WARN] 解析 plusconfig 失败: {exc}，使用默认配置。", file=sys.stderr)
    return config


def collect_json_files(input_path: Path) -> List[Path]:
    if input_path.is_file():
        return [input_path] if input_path.suffix == ".json" else []
    if not input_path.is_dir():
        return []
    files: List[Path] = []
    for entry in sorted(input_path.iterdir()):
        if not entry.is_file():
            continue
        if entry.suffix != ".json":
            continue
        if entry.name.startswith("module_"):
            continue
        files.append(entry)
    return files


def add_edge(
    directed: List[List[int]],
    undirected: List[List[int]],
    from_index: int,
    to_index: int,
) -> None:
    directed[from_index].append(to_index)
    undirected[from_index].append(to_index)
    undirected[to_index].append(from_index)


def scan_json_for_ids(
    value: Any,
    key: str,
    from_index: int,
    id_to_index: Dict[str, int],
    ignored_labels: Set[str],
    seen: Set[int],
    directed: List[List[int]],
    undirected: List[List[int]],
) -> None:
    if key and key in ignored_labels:
        return

    if isinstance(value, dict):
        for child_key, child_value in value.items():
            if child_key in {"wires", "id"}:
                continue
            scan_json_for_ids(
                child_value,
                child_key,
                from_index,
                id_to_index,
                ignored_labels,
                seen,
                directed,
                undirected,
            )
        return

    if isinstance(value, list):
        for child in value:
            scan_json_for_ids(
                child,
                key,
                from_index,
                id_to_index,
                ignored_labels,
                seen,
                directed,
                undirected,
            )
        return

    if isinstance(value, str):
        target_index = id_to_index.get(value)
        if target_index is None:
            return
        if target_index in seen:
            return
        seen.add(target_index)
        add_edge(directed, undirected, from_index, target_index)


def build_graph(
    array: Any,
    ignored_labels: Set[str],
    use_all_wires: bool,
) -> Graph:
    nodes: List[Node] = []
    id_to_index: Dict[str, int] = {}
    if not isinstance(array, list):
        return Graph(nodes=nodes, id_to_index=id_to_index, directed_edges=[], undirected_edges=[])

    for node_json in array:
        if not isinstance(node_json, dict):
            continue
        node_id = node_json.get("id")
        if not isinstance(node_id, str):
            continue
        id_to_index[node_id] = len(nodes)
        nodes.append(Node(node_id=node_id, data=node_json))

    directed = [[] for _ in nodes]
    undirected = [[] for _ in nodes]

    for idx, node in enumerate(nodes):
        node_json = node.data
        seen: Set[int] = set()

        wires = node_json.get("wires")
        if isinstance(wires, list):
            groups = wires if use_all_wires else wires[:1]
            for group in groups:
                if not isinstance(group, list):
                    continue
                for target in group:
                    if not isinstance(target, str):
                        continue
                    target_index = id_to_index.get(target)
                    if target_index is None or target_index in seen:
                        continue
                    seen.add(target_index)
                    add_edge(directed, undirected, idx, target_index)

        for key, value in node_json.items():
            if key in {"wires", "id"}:
                continue
            scan_json_for_ids(
                value,
                key,
                idx,
                id_to_index,
                ignored_labels,
                seen,
                directed,
                undirected,
            )

    return Graph(nodes=nodes, id_to_index=id_to_index, directed_edges=directed, undirected_edges=undirected)


def is_closed(graph: Graph, in_set: List[bool]) -> bool:
    for idx, included in enumerate(in_set):
        if not included:
            continue
        for target in graph.directed_edges[idx]:
            if not in_set[target]:
                return False
    return True


def add_if_valid(
    output: List[List[int]],
    graph: Graph,
    nodes: List[int],
    lower: int,
    upper: int,
) -> None:
    if len(nodes) < lower or len(nodes) > upper:
        return
    in_set = [False] * len(graph.nodes)
    for node in nodes:
        in_set[node] = True
    if not is_closed(graph, in_set):
        return
    output.append(nodes.copy())


def enumerate_disconnected_rec(
    output: List[List[int]],
    graph: Graph,
    current: List[int],
    index: int,
    lower: int,
    upper: int,
) -> None:
    if len(current) > upper:
        return
    if index == len(graph.nodes):
        add_if_valid(output, graph, current, lower, upper)
        return
    current.append(index)
    enumerate_disconnected_rec(output, graph, current, index + 1, lower, upper)
    current.pop()
    enumerate_disconnected_rec(output, graph, current, index + 1, lower, upper)


def enumerate_connected_rec(
    output: List[List[int]],
    graph: Graph,
    current: List[int],
    candidates: List[int],
    in_set: List[bool],
    start: int,
    lower: int,
    upper: int,
) -> None:
    add_if_valid(output, graph, current, lower, upper)
    if len(current) >= upper:
        return

    candidates_snapshot = candidates.copy()
    for candidate in candidates_snapshot:
        if in_set[candidate]:
            continue
        current.append(candidate)
        in_set[candidate] = True

        new_candidates = [c for c in candidates if c != candidate]
        for neighbor in graph.undirected_edges[candidate]:
            if neighbor > start and not in_set[neighbor] and neighbor not in new_candidates:
                new_candidates.append(neighbor)

        enumerate_connected_rec(
            output,
            graph,
            current,
            new_candidates,
            in_set,
            start,
            lower,
            upper,
        )

        in_set[candidate] = False
        current.pop()


def enumerate_subgraphs(
    graph: Graph,
    lower: int,
    upper: int,
    allow_disconnected: bool,
) -> List[List[int]]:
    if not graph.nodes or lower > upper or upper <= 0:
        return []

    output: List[List[int]] = []
    if allow_disconnected:
        enumerate_disconnected_rec(output, graph, [], 0, lower, upper)
        return output

    for start in range(len(graph.nodes)):
        current = [start]
        in_set = [False] * len(graph.nodes)
        in_set[start] = True
        candidates = [n for n in graph.undirected_edges[start] if n > start]
        enumerate_connected_rec(output, graph, current, candidates, in_set, start, lower, upper)
    return output


def join_labels(labels: Sequence[str]) -> str:
    return "_".join(labels)


def write_modules(
    input_path: Path,
    graph: Graph,
    subgraphs: List[List[int]],
    ignored_labels: Sequence[str],
    verbose_debug: bool,
) -> None:
    counter_by_size: Dict[int, int] = {}
    base = input_path.stem
    label_part = join_labels(ignored_labels)

    for nodes in subgraphs:
        size = len(nodes)
        counter_by_size[size] = counter_by_size.get(size, 0) + 1
        index = counter_by_size[size]

        filename = f"module_{base}_"
        if label_part:
            filename += f"{label_part}_"
        filename += f"{size}_{index}.json"

        out_path = input_path.parent / filename
        payload = [graph.nodes[idx].data for idx in nodes]
        try:
            out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=4), encoding="utf-8")
        except Exception as exc:  # noqa: BLE001 - keep output student-friendly
            print(f"[WARN] 无法写入文件: {out_path} ({exc})", file=sys.stderr)
            continue

        if verbose_debug:
            print(f"[MODULE] {out_path.name}")
            print(f"  节点数量: {size}")
            print("  节点列表: " + ", ".join(graph.nodes[idx].node_id for idx in nodes))


def print_graph_summary(graph: Graph) -> None:
    print(f"[INFO] 节点数量: {len(graph.nodes)}")
    edge_count = sum(len(edges) for edges in graph.directed_edges)
    print(f"[INFO] 有向连接数量: {edge_count}")
    node_ids = " ".join(node.node_id for node in graph.nodes)
    print(f"[INFO] 节点列表: {node_ids}")


def load_json_file(path: Path) -> Any:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as exc:  # noqa: BLE001 - output must be verbose
        print(f"[ERROR] JSON 解析失败: {path} ({exc})", file=sys.stderr)
        return None


def print_usage() -> None:
    print("用法: mytool <目标文件/目录> <下界> <上界> [忽略标签1 忽略标签2 ...]")
    print("示例: mytool ./json 5 6 z")


def main(argv: Sequence[str]) -> int:
    if len(argv) < 4:
        print_usage()
        return 1

    input_path = Path(argv[1])
    try:
        lower = int(argv[2])
        upper = int(argv[3])
    except ValueError:
        print("[ERROR] 下界和上界必须是非负整数。", file=sys.stderr)
        return 1
    if lower <= 0 or upper <= 0:
        print("[ERROR] 下界和上界必须是正整数。", file=sys.stderr)
        return 1
    if lower > upper:
        print("[ERROR] 下界不能大于上界。", file=sys.stderr)
        return 1

    if not input_path.exists():
        print(f"[ERROR] 目标路径不存在: {input_path}", file=sys.stderr)
        return 1

    ignored_labels = list(argv[4:])

    if input_path.is_dir():
        config_path = input_path / "plusconfig.json"
    else:
        config_path = input_path.parent / "plusconfig.json"
    if not config_path.exists():
        config_path = Path.cwd() / "plusconfig.json"

    config = load_plus_config(config_path)
    files = collect_json_files(input_path)
    if not files:
        print("[ERROR] 未找到可处理的 JSON 文件。", file=sys.stderr)
        return 1

    ignored_map = set(ignored_labels)
    if config.verbose_debug:
        print(f"[DEBUG] 使用配置文件: {config_path}")
        print(
            "[DEBUG] use_all_wires="
            f"{str(config.use_all_wires).lower()}, "
            "allow_disconnected="
            f"{str(config.allow_disconnected).lower()}, "
            "verbose_debug="
            f"{str(config.verbose_debug).lower()}"
        )
        print(f"[DEBUG] 输入路径: {input_path}")
        print(f"[DEBUG] 子图规模范围: [{lower}, {upper}]")
        if ignored_labels:
            print("[DEBUG] 忽略标签: " + " ".join(ignored_labels))
        else:
            print("[DEBUG] 忽略标签: (无)")
        print(f"[DEBUG] 待处理文件数量: {len(files)}")

    for file_path in files:
        data = load_json_file(file_path)
        if data is None:
            continue
        print(f"\n[FILE] {file_path}")
        graph = build_graph(data, ignored_map, config.use_all_wires)
        if config.verbose_debug:
            print_graph_summary(graph)
        subgraphs = enumerate_subgraphs(graph, lower, upper, config.allow_disconnected)
        print(f"[INFO] 满足条件的子图数量: {len(subgraphs)}")
        write_modules(file_path, graph, subgraphs, ignored_labels, config.verbose_debug)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
